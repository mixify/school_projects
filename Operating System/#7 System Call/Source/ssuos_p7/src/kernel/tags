!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AFLAGS	Makefile	/^AFLAGS = -f elf32$/;"	m
ASSERT	arch/interrupt.c	39;"	d	file:
ASSERT	bitmap.c	12;"	d	file:
ASSERT	include/debug.h	27;"	d
ASSERT	include/debug.h	31;"	d
ASSERT	include/debug.h	37;"	d
ASSERT	list.c	4;"	d	file:
ASSERT	synch.c	7;"	d	file:
ATA_ALT_ST_REG	include/device/ata.h	15;"	d
ATA_CMD_CACHE_FLUSH	include/device/ata.h	43;"	d
ATA_CMD_CACHE_FLUSH_EXT	include/device/ata.h	44;"	d
ATA_CMD_IDENTIFY	include/device/ata.h	47;"	d
ATA_CMD_IDENTIFY_PACKET	include/device/ata.h	46;"	d
ATA_CMD_PACKET	include/device/ata.h	45;"	d
ATA_CMD_READ_DMA	include/device/ata.h	37;"	d
ATA_CMD_READ_DMA_EXT	include/device/ata.h	38;"	d
ATA_CMD_READ_PIO	include/device/ata.h	35;"	d
ATA_CMD_READ_PIO_EXT	include/device/ata.h	36;"	d
ATA_CMD_WRITE_DMA	include/device/ata.h	41;"	d
ATA_CMD_WRITE_DMA_EXT	include/device/ata.h	42;"	d
ATA_CMD_WRITE_PIO	include/device/ata.h	39;"	d
ATA_CMD_WRITE_PIO_EXT	include/device/ata.h	40;"	d
ATA_DEV_CTRL_REG	include/device/ata.h	16;"	d
ATA_DEV_NUM	include/device/ata.h	55;"	d
ATA_DRHD_DEF	include/device/ata.h	30;"	d
ATA_DRHD_LBA	include/device/ata.h	33;"	d
ATA_DRHD_MST	include/device/ata.h	31;"	d
ATA_DRHD_SLV	include/device/ata.h	32;"	d
ATA_MASTER	include/device/ata.h	18;"	d
ATA_REG_CMD	include/device/ata.h	14;"	d
ATA_REG_DATA	include/device/ata.h	6;"	d
ATA_REG_DEVICE	include/device/ata.h	12;"	d
ATA_REG_ERR	include/device/ata.h	7;"	d
ATA_REG_LBAH	include/device/ata.h	11;"	d
ATA_REG_LBAL	include/device/ata.h	9;"	d
ATA_REG_LBAM	include/device/ata.h	10;"	d
ATA_REG_NSECT	include/device/ata.h	8;"	d
ATA_REG_STATUS	include/device/ata.h	13;"	d
ATA_SECOR_SIZE	include/device/ata.h	52;"	d
ATA_SLAVE	include/device/ata.h	19;"	d
ATA_SR_BSY	include/device/ata.h	21;"	d
ATA_SR_CORR	include/device/ata.h	26;"	d
ATA_SR_DF	include/device/ata.h	23;"	d
ATA_SR_DRDY	include/device/ata.h	22;"	d
ATA_SR_DRQ	include/device/ata.h	25;"	d
ATA_SR_DSC	include/device/ata.h	24;"	d
ATA_SR_ERR	include/device/ata.h	28;"	d
ATA_SR_IDX	include/device/ata.h	27;"	d
ATA_WAIT_BUSY	include/device/ata.h	49;"	d
ATA_WAIT_IDLE	include/device/ata.h	50;"	d
AUTHOR	arch/Main.c	/^const char* AUTHOR = "OSLAB";$/;"	v
AUTHOR	build/Main.s	/^AUTHOR:$/;"	l
Address	arch/interrupt.c	/^	unsigned long Address;$/;"	m	struct:_IDTR	file:
BITMAP_ERROR	include/bitmap.h	34;"	d
BITMASK	include/vaddr.h	15;"	d
BLK_DEV_CDR	include/device/block.h	14;"	d
BLK_DEV_HDD	include/device/block.h	11;"	d
BLK_DEV_OTH	include/device/block.h	15;"	d
BLK_DEV_ROM	include/device/block.h	10;"	d
BLK_DEV_SSD	include/device/block.h	12;"	d
BLK_DEV_USB	include/device/block.h	13;"	d
BLK_SEC_SIZE	include/device/block.h	8;"	d
BOOL	include/type.h	/^typedef char BOOL;$/;"	t
BUFSIZ	include/ssulib.h	7;"	d
BUILD_COMMAND	Makefile	/^BUILD_COMMAND = -o $(BUILD_PATH)\/$@$/;"	m
BUILD_PATH	Makefile	/^BUILD_PATH = .\/build$/;"	m
BYTE	include/type.h	/^typedef unsigned char BYTE;$/;"	t
CC	Makefile	/^CC = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -O0 -g -I.\/include -ffreestanding -m32 -nostdlib -nostdinc -static -fno-stack-protector$/;"	m
CHAR	include/device/console.h	/^} CHAR;$/;"	t	typeref:struct:kChStruct
CHAR	stdio.c	/^        CHAR = 1,               \/* hh *\/$/;"	e	enum:printf_conversion::__anon3	file:
CHAR_BIT	include/limits.h	4;"	d
CHAR_MAX	include/limits.h	12;"	d
CHAR_MAX	include/limits.h	15;"	d
CHAR_MIN	include/limits.h	11;"	d
CHAR_MIN	include/limits.h	14;"	d
CMDNUM	proc/proc.c	407;"	d	file:
CODE_SEGMENT	arch/interrupt.c	17;"	d	file:
COMMON_COMMAND	Makefile	/^COMMON_COMMAND = $(BUILD_COMMAND) -c $^ $(CFLAGS)$/;"	m
CR0_FLAG_PE	include/mem/paging.h	8;"	d
CR0_FLAG_PG	include/mem/paging.h	7;"	d
CapslockFlag	include/device/kbd.h	/^	BOOL CapslockFlag;$/;"	m	struct:Key_Status_Struct
CmdList	proc/proc.c	/^} CmdList;$/;"	t	typeref:struct:__anon1	file:
CodeSelector	arch/interrupt.c	/^	unsigned short CodeSelector;$/;"	m	struct:_ID	file:
ConvertScancodeToASCII	device/kbd.c	/^BOOL ConvertScancodeToASCII(BYTE Scancode, BYTE *Asciicode)$/;"	f
DEVICES_PARTITION_H	include/device/partition.h	2;"	d
DEVOP_READ	include/filesys/fs.h	22;"	d
DEVOP_WRITE	include/filesys/fs.h	23;"	d
DIR	Makefile	/^DIR := ${CURDIR}$/;"	m
DIV_ROUND_UP	include/round.h	10;"	d
ELEM_BITS	bitmap.c	18;"	d	file:
ENTRY	Makefile	/^ENTRY = ssuos_main$/;"	m
ExtentedFlag	include/device/kbd.h	/^	BOOL ExtentedFlag;$/;"	m	struct:Key_Status_Struct
FALSE	include/type.h	13;"	d
FILENAME_LEN	include/filesys/inode.h	11;"	d
FIRST_SPORT	device/console.c	17;"	d	file:
FLAG_IF	arch/interrupt.c	153;"	d	file:
FLAG_MBS	arch/interrupt.c	152;"	d	file:
GROUP	stdio.c	/^        GROUP = 1 << 5          \/* '\\'' *\/$/;"	e	enum:printf_conversion::__anon2	file:
Glob_x	include/device/console.h	/^int Glob_x;$/;"	v
Glob_y	include/device/console.h	/^int Glob_y;$/;"	v
HLT	include/interrupt.h	4;"	d
HSCREEN	device/console.c	9;"	d	file:
HighOffset	arch/interrupt.c	/^	unsigned short HighOffset;$/;"	m	struct:_ID	file:
INODE_PER_BLOCK	include/filesys/inode.h	12;"	d
INO_ROOTDIR	include/filesys/inode.h	8;"	d
INT	stdio.c	/^        INT = 3,                \/* (none) *\/$/;"	e	enum:printf_conversion::__anon3	file:
INT16_MAX	include/stdint.h	9;"	d
INT16_MAX	include/type.h	34;"	d
INT16_MIN	include/stdint.h	10;"	d
INT16_MIN	include/type.h	35;"	d
INT32_MAX	include/stdint.h	13;"	d
INT32_MAX	include/type.h	38;"	d
INT32_MIN	include/stdint.h	14;"	d
INT32_MIN	include/type.h	39;"	d
INT64_MAX	include/stdint.h	17;"	d
INT64_MAX	include/type.h	42;"	d
INT64_MIN	include/stdint.h	18;"	d
INT64_MIN	include/type.h	43;"	d
INT8_MAX	include/stdint.h	5;"	d
INT8_MAX	include/type.h	30;"	d
INT8_MIN	include/stdint.h	6;"	d
INT8_MIN	include/type.h	31;"	d
INTMAX	stdio.c	/^        INTMAX = 4,             \/* j *\/$/;"	e	enum:printf_conversion::__anon3	file:
INTMAX_MAX	include/stdint.h	41;"	d
INTMAX_MAX	include/type.h	66;"	d
INTMAX_MIN	include/stdint.h	40;"	d
INTMAX_MIN	include/type.h	65;"	d
INTPTR_MAX	include/stdint.h	34;"	d
INTPTR_MAX	include/type.h	59;"	d
INTPTR_MIN	include/stdint.h	33;"	d
INTPTR_MIN	include/type.h	58;"	d
INTR_MAX	include/intr-stubs.h	4;"	d
INTR_OFF	include/interrupt.h	/^	INTR_OFF,             \/* Interrupts disabled. *\/$/;"	e	enum:intr_level
INTR_ON	include/interrupt.h	/^	INTR_ON               \/* Interrupts enabled. *\/$/;"	e	enum:intr_level
INT_MAX	include/limits.h	22;"	d
INT_MIN	include/limits.h	23;"	d
IO_BASE	device/console.c	16;"	d	file:
KBDMAPSIZE	include/device/kbd.h	7;"	d
KERNEL_ADDR	include/mem/paging.h	34;"	d
KERNEL_HEAP	include/mem/paging.h	35;"	d
KEY_BSPACE	include/device/kbd.h	27;"	d
KEY_CAPS	include/device/kbd.h	14;"	d
KEY_ESC	include/device/kbd.h	9;"	d
KEY_F1	include/device/kbd.h	15;"	d
KEY_F10	include/device/kbd.h	24;"	d
KEY_F11	include/device/kbd.h	25;"	d
KEY_F12	include/device/kbd.h	26;"	d
KEY_F2	include/device/kbd.h	16;"	d
KEY_F3	include/device/kbd.h	17;"	d
KEY_F4	include/device/kbd.h	18;"	d
KEY_F5	include/device/kbd.h	19;"	d
KEY_F6	include/device/kbd.h	20;"	d
KEY_F7	include/device/kbd.h	21;"	d
KEY_F8	include/device/kbd.h	22;"	d
KEY_F9	include/device/kbd.h	23;"	d
KEY_LALT	include/device/kbd.h	12;"	d
KEY_PRTSCN	include/device/kbd.h	11;"	d
KEY_RSHIFT	include/device/kbd.h	10;"	d
KEY_SPACE	include/device/kbd.h	13;"	d
KEY_TAB	include/device/kbd.h	28;"	d
KStat	device/kbd.c	/^static Key_Status KStat;$/;"	v	file:
Kbd_Map	device/kbd.c	/^static BYTE Kbd_Map[4][KBDMAPSIZE] = {$/;"	v	file:
Key_Status	include/device/kbd.h	/^} Key_Status;$/;"	t	typeref:struct:Key_Status_Struct
Key_Status_Struct	include/device/kbd.h	/^typedef struct Key_Status_Struct {$/;"	s
LEFT	vsprintk.c	7;"	d	file:
LINE_STATUS	device/console.c	18;"	d	file:
LIST_INITIALIZER	include/list.h	121;"	d
LLONG_MAX	include/limits.h	30;"	d
LLONG_MIN	include/limits.h	31;"	d
LOADER_ARGS	include/loader.h	18;"	d
LOADER_ARGS_LEN	include/loader.h	24;"	d
LOADER_ARG_CNT	include/loader.h	19;"	d
LOADER_ARG_CNT_LEN	include/loader.h	25;"	d
LOADER_BASE	include/loader.h	5;"	d
LOADER_END	include/loader.h	6;"	d
LOADER_KERN_BASE	include/loader.h	9;"	d
LOADER_PARTS	include/loader.h	17;"	d
LOADER_PARTS_LEN	include/loader.h	23;"	d
LOADER_PHYS_BASE	include/loader.h	13;"	d
LOADER_SIG	include/loader.h	16;"	d
LOADER_SIG_LEN	include/loader.h	22;"	d
LONG	stdio.c	/^        LONG = 5,               \/* l *\/$/;"	e	enum:printf_conversion::__anon3	file:
LONGLONG	stdio.c	/^        LONGLONG = 6,           \/* ll *\/$/;"	e	enum:printf_conversion::__anon3	file:
LONG_MAX	include/limits.h	26;"	d
LONG_MIN	include/limits.h	27;"	d
LowOffset	arch/interrupt.c	/^	unsigned short LowOffset;$/;"	m	struct:_ID	file:
MEM_SIZE	mem/mm.c	/^static unsigned long MEM_SIZE;$/;"	v	file:
MINUS	stdio.c	/^        MINUS = 1 << 0,         \/* '-' *\/$/;"	e	enum:printf_conversion::__anon2	file:
MODIFIER	arch/Main.c	/^const char* MODIFIER = "You";$/;"	v
MODIFIER	build/Main.s	/^MODIFIER:$/;"	l
NASM	Makefile	/^NASM = nasm$/;"	m
NOT_REACHED	include/debug.h	28;"	d
NOT_REACHED	include/debug.h	35;"	d
NOT_REACHED	include/debug.h	38;"	d
NO_INLINE	include/debug.h	9;"	d
NO_RETURN	include/debug.h	8;"	d
NR_FILEDES	include/filesys/file.h	6;"	d
NSCROLL	device/console.c	12;"	d	file:
NULL	include/type.h	16;"	d
NUM_DIRECT	include/filesys/inode.h	9;"	d
NUM_INODE	include/filesys/inode.h	10;"	d
NUM_INODEBLOCK	include/filesys/fs.h	18;"	d
NumlockFLag	include/device/kbd.h	/^	BOOL NumlockFLag;	$/;"	m	struct:Key_Status_Struct
OBJS	Makefile	/^OBJS = $(BUILD_PATH)\/Main.o $(BUILD_PATH)\/io.o $(BUILD_PATH)\/pit.o $(BUILD_PATH)\/interrupt.o $(BUILD_PATH)\/kbd.o $(BUILD_PATH)\/crset.o $(BUILD_PATH)\/paging.o \\$/;"	m
O_RDONLY	include/filesys/file.h	8;"	d
O_RDWR	include/filesys/file.h	10;"	d
O_WRONLY	include/filesys/file.h	9;"	d
PACKED	include/packed.h	8;"	d
PAGE_ADDR_AVAIL	include/mem/paging.h	21;"	d
PAGE_ADDR_BASE	include/mem/paging.h	22;"	d
PAGE_DIR_SIZE	include/mem/paging.h	32;"	d
PAGE_FLAG_ACCESS	include/mem/paging.h	15;"	d
PAGE_FLAG_AVAIL	include/mem/paging.h	16;"	d
PAGE_FLAG_CACHE	include/mem/paging.h	14;"	d
PAGE_FLAG_DIRTY	include/mem/paging.h	17;"	d
PAGE_FLAG_GLOB	include/mem/paging.h	20;"	d
PAGE_FLAG_PRESENT	include/mem/paging.h	10;"	d
PAGE_FLAG_PTA	include/mem/paging.h	19;"	d
PAGE_FLAG_RW	include/mem/paging.h	11;"	d
PAGE_FLAG_SIZE	include/mem/paging.h	18;"	d
PAGE_FLAG_USER	include/mem/paging.h	12;"	d
PAGE_FLAG_WRITE	include/mem/paging.h	13;"	d
PAGE_MASK_BASE	include/mem/paging.h	24;"	d
PAGE_MASK_PDE	include/mem/paging.h	25;"	d
PAGE_MASK_PTE	include/mem/paging.h	26;"	d
PAGE_OFFSET_PDE	include/mem/paging.h	27;"	d
PAGE_OFFSET_PTE	include/mem/paging.h	28;"	d
PAGE_SIZE	include/mem/paging.h	30;"	d
PAGE_TBL_SIZE	include/mem/paging.h	31;"	d
PANIC	include/debug.h	14;"	d
PGBITS	include/vaddr.h	19;"	d
PGMASK	include/vaddr.h	21;"	d
PGSHIFT	include/vaddr.h	18;"	d
PGSIZE	include/vaddr.h	20;"	d
PHYS_BASE	include/vaddr.h	53;"	d
PID0_PAGE_DIR	mem/paging.c	/^uint32_t *PID0_PAGE_DIR;$/;"	v
PIT_BCD	include/device/pit.h	27;"	d
PIT_BINARY	include/device/pit.h	26;"	d
PIT_CHANNEL0	include/device/pit.h	4;"	d
PIT_CHANNEL1	include/device/pit.h	5;"	d
PIT_CHANNEL2	include/device/pit.h	6;"	d
PIT_COMMAND	include/device/pit.h	7;"	d
PIT_COUNTER0	include/device/pit.h	9;"	d
PIT_COUNTER1	include/device/pit.h	10;"	d
PIT_COUNTER2	include/device/pit.h	11;"	d
PIT_FRQ_HZ	include/device/pit.h	30;"	d
PIT_HZ	include/device/pit.h	29;"	d
PIT_MODE0	include/device/pit.h	19;"	d
PIT_MODE1	include/device/pit.h	20;"	d
PIT_MODE2	include/device/pit.h	21;"	d
PIT_MODE3	include/device/pit.h	22;"	d
PIT_MODE4	include/device/pit.h	23;"	d
PIT_MODE5	include/device/pit.h	24;"	d
PIT_READBACK	include/device/pit.h	12;"	d
PIT_RW_COUNTER_LATCH	include/device/pit.h	14;"	d
PIT_RW_LBYTE	include/device/pit.h	15;"	d
PIT_RW_LMBYTE	include/device/pit.h	17;"	d
PIT_RW_MBYTE	include/device/pit.h	16;"	d
PLUS	stdio.c	/^        PLUS = 1 << 1,          \/* '+' *\/$/;"	e	enum:printf_conversion::__anon2	file:
PLUS	vsprintk.c	5;"	d	file:
POUND	stdio.c	/^        POUND = 1 << 3,         \/* '#' *\/$/;"	e	enum:printf_conversion::__anon2	file:
PRINTF_FORMAT	include/debug.h	10;"	d
PRIX16	include/inttypes.h	18;"	d
PRIX32	include/inttypes.h	25;"	d
PRIX64	include/inttypes.h	32;"	d
PRIX8	include/inttypes.h	11;"	d
PRIXMAX	include/inttypes.h	39;"	d
PRIXPTR	include/inttypes.h	46;"	d
PRId16	include/inttypes.h	13;"	d
PRId32	include/inttypes.h	20;"	d
PRId64	include/inttypes.h	27;"	d
PRId8	include/inttypes.h	6;"	d
PRIdMAX	include/inttypes.h	34;"	d
PRIdPTR	include/inttypes.h	41;"	d
PRIi16	include/inttypes.h	14;"	d
PRIi32	include/inttypes.h	21;"	d
PRIi64	include/inttypes.h	28;"	d
PRIi8	include/inttypes.h	7;"	d
PRIiMAX	include/inttypes.h	35;"	d
PRIiPTR	include/inttypes.h	42;"	d
PRIo16	include/inttypes.h	15;"	d
PRIo32	include/inttypes.h	22;"	d
PRIo64	include/inttypes.h	29;"	d
PRIo8	include/inttypes.h	8;"	d
PRIoMAX	include/inttypes.h	36;"	d
PRIoPTR	include/inttypes.h	43;"	d
PRIu16	include/inttypes.h	16;"	d
PRIu32	include/inttypes.h	23;"	d
PRIu64	include/inttypes.h	30;"	d
PRIu8	include/inttypes.h	9;"	d
PRIuMAX	include/inttypes.h	37;"	d
PRIuPTR	include/inttypes.h	44;"	d
PRIx16	include/inttypes.h	17;"	d
PRIx32	include/inttypes.h	24;"	d
PRIx64	include/inttypes.h	31;"	d
PRIx8	include/inttypes.h	10;"	d
PRIxMAX	include/inttypes.h	38;"	d
PRIxPTR	include/inttypes.h	45;"	d
PROC_BLOCK	include/proc/proc.h	/^	PROC_BLOCK,$/;"	e	enum:p_state
PROC_NUM_MAX	proc/proc.c	18;"	d	file:
PROC_RUN	include/proc/proc.h	/^	PROC_RUN,	$/;"	e	enum:p_state
PROC_STOP	include/proc/proc.h	/^	PROC_STOP,$/;"	e	enum:p_state
PROC_UNUSED	include/proc/proc.h	/^	PROC_UNUSED,$/;"	e	enum:p_state
PROC_ZOMBIE	include/proc/proc.h	/^	PROC_ZOMBIE,$/;"	e	enum:p_state
PTRDIFFT	stdio.c	/^        PTRDIFFT = 7,           \/* t *\/$/;"	e	enum:printf_conversion::__anon3	file:
PTRDIFF_MAX	include/stdint.h	47;"	d
PTRDIFF_MAX	include/type.h	72;"	d
PTRDIFF_MIN	include/stdint.h	46;"	d
PTRDIFF_MIN	include/type.h	71;"	d
PauseFlag	include/device/kbd.h	/^	int PauseFlag;	$/;"	m	struct:Key_Status_Struct
PrintChar	device/console.c	/^void PrintChar(int x, int y, const char String) $/;"	f
PrintCharToScreen	device/console.c	/^void PrintCharToScreen(int x, int y, const char *pString) $/;"	f
REAL	arch/i386/intr-stubs.S	/^#define REAL                                    \\$/;"	d
REFRESH_FPS	arch/interrupt.c	16;"	d	file:
REGSYS	arch/syscall.c	73;"	d	file:
ROUND_DOWN	include/round.h	14;"	d
ROUND_UP	include/round.h	6;"	d
SCHAR_MAX	include/limits.h	6;"	d
SCHAR_MIN	include/limits.h	7;"	d
SCREEN_SCROLL	include/device/console.h	17;"	d
SCROLL_END	device/console.c	26;"	d	file:
SECTORCOUNT	include/filesys/fs.h	20;"	d
SEEK_CUR	include/filesys/file.h	13;"	d
SEEK_END	include/filesys/file.h	14;"	d
SEEK_SET	include/filesys/file.h	12;"	d
SEL_KCSEG	include/loader.h	30;"	d
SEL_KDSEG	include/loader.h	31;"	d
SEL_NULL	include/loader.h	29;"	d
SERIAL_STDOUT	include/device/console.h	18;"	d
SHORT	stdio.c	/^        SHORT = 2,              \/* h *\/$/;"	e	enum:printf_conversion::__anon3	file:
SHRT_MAX	include/limits.h	18;"	d
SHRT_MIN	include/limits.h	19;"	d
SIGN	vsprintk.c	4;"	d	file:
SIZET	stdio.c	/^        SIZET = 8               \/* z *\/$/;"	e	enum:printf_conversion::__anon3	file:
SIZE_MAX	include/stdint.h	49;"	d
SIZE_MAX	include/type.h	74;"	d
SIZE_SCREEN	device/console.c	11;"	d	file:
SIZE_SCROLL	device/console.c	13;"	d	file:
SLEEP_FREQ	proc/proc.c	327;"	d	file:
SMALL	vsprintk.c	9;"	d	file:
SPACE	stdio.c	/^        SPACE = 1 << 2,         \/* ' ' *\/$/;"	e	enum:printf_conversion::__anon2	file:
SPACE	vsprintk.c	6;"	d	file:
SPECIAL	vsprintk.c	8;"	d	file:
SSU_BITMAP_BLOCK	include/filesys/fs.h	13;"	d
SSU_BLOCK_SIZE	include/filesys/fs.h	7;"	d
SSU_BOOT_BLOCK	include/filesys/fs.h	9;"	d
SSU_DATA_BLOCK	include/filesys/fs.h	15;"	d
SSU_INODE_BLOCK	include/filesys/fs.h	14;"	d
SSU_RESERVED_BLOCK	include/filesys/fs.h	10;"	d
SSU_SB_MAGIC	include/filesys/fs.h	6;"	d
SSU_SUPER_BLOCK	include/filesys/fs.h	12;"	d
SSU_TYPE_DIR	include/filesys/inode.h	16;"	d
SSU_TYPE_FILE	include/filesys/inode.h	15;"	d
SSU_TYPE_INVALID	include/filesys/inode.h	14;"	d
STACK_SIZE	proc/proc.c	17;"	d	file:
STDIN_FILENO	include/stdio.h	15;"	d
STDOUT_FILENO	include/stdio.h	16;"	d
STUB	arch/i386/intr-stubs.S	/^#define STUB(NUMBER, TYPE)                      \\$/;"	d
STUDENT_NAME	device/ata.c	13;"	d	file:
SYSCALL_ARG_MAX	arch/interrupt.c	254;"	d	file:
SYS_EXIT	include/syscall.h	/^	SYS_EXIT,$/;"	e	enum:SYS_LIST
SYS_FORK	include/syscall.h	/^	SYS_FORK = 0,$/;"	e	enum:SYS_LIST
SYS_LIST	include/syscall.h	/^enum SYS_LIST {$/;"	g
SYS_NUM	include/syscall.h	/^	SYS_NUM,$/;"	e	enum:SYS_LIST
SYS_OPEN	include/syscall.h	/^	SYS_OPEN,$/;"	e	enum:SYS_LIST
SYS_READ	include/syscall.h	/^	SYS_READ,$/;"	e	enum:SYS_LIST
SYS_SHUTDOWN	include/syscall.h	/^	SYS_SHUTDOWN,$/;"	e	enum:SYS_LIST
SYS_SSUREAD	include/syscall.h	/^	SYS_SSUREAD,$/;"	e	enum:SYS_LIST
SYS_WAIT	include/syscall.h	/^	SYS_WAIT,$/;"	e	enum:SYS_LIST
SYS_WRITE	include/syscall.h	/^	SYS_WRITE,$/;"	e	enum:SYS_LIST
ScrolllockFlag	include/device/kbd.h	/^	BOOL ScrolllockFlag;$/;"	m	struct:Key_Status_Struct
ShiftFlag	include/device/kbd.h	/^	BOOL ShiftFlag; 	$/;"	m	struct:Key_Status_Struct
Size	arch/interrupt.c	/^	unsigned short Size;$/;"	m	struct:_IDTR	file:
THREADS_LOADER_H	include/loader.h	2;"	d
THREADS_VADDR_H	include/vaddr.h	2;"	d
THR_EMPTY	device/console.c	19;"	d	file:
TIMER_MAX	arch/interrupt.c	15;"	d	file:
TOKNUM	proc/proc.c	408;"	d	file:
TRUE	include/type.h	12;"	d
Type	arch/interrupt.c	/^	unsigned short Type;$/;"	m	struct:_ID	file:
UCHAR_MAX	include/limits.h	8;"	d
UINT16_MAX	include/stdint.h	24;"	d
UINT16_MAX	include/type.h	49;"	d
UINT32_MAX	include/stdint.h	27;"	d
UINT32_MAX	include/type.h	52;"	d
UINT64_MAX	include/stdint.h	30;"	d
UINT64_MAX	include/type.h	55;"	d
UINT8_MAX	include/stdint.h	21;"	d
UINT8_MAX	include/type.h	46;"	d
UINTMAX_MAX	include/stdint.h	44;"	d
UINTMAX_MAX	include/type.h	69;"	d
UINTPTR_MAX	include/stdint.h	37;"	d
UINTPTR_MAX	include/type.h	62;"	d
UINT_MAX	include/limits.h	24;"	d
ULLONG_MAX	include/limits.h	32;"	d
ULONG_MAX	include/limits.h	28;"	d
UNUSED	include/debug.h	7;"	d
UNVALID_BLOCK	include/filesys/fs.h	8;"	d
USHRT_MAX	include/limits.h	20;"	d
UpdateKeyStat	device/kbd.c	/^void UpdateKeyStat(BYTE Scancode)$/;"	f
VERSION	arch/Main.c	/^const char* VERSION = "0.1.07";$/;"	v
VERSION	build/Main.s	/^VERSION:$/;"	l
VIDIO_MEMORY	device/console.c	14;"	d	file:
VOLNAME_LEN	include/filesys/fs.h	17;"	d
VSCREEN	device/console.c	10;"	d	file:
ZERO	stdio.c	/^        ZERO = 1 << 4,          \/* '0' *\/$/;"	e	enum:printf_conversion::__anon2	file:
ZEROPAD	vsprintk.c	3;"	d	file:
_ADDRESSOF	include/stdarg.h	6;"	d
_ID	arch/interrupt.c	/^typedef struct _ID$/;"	s	file:
_ID	arch/interrupt.c	/^} _ID;$/;"	t	typeref:struct:_ID	file:
_IDTR	arch/interrupt.c	/^typedef struct _IDTR$/;"	s	file:
_IDTR	arch/interrupt.c	/^} _IDTR;$/;"	t	typeref:struct:_IDTR	file:
_INTR_STUBS_H_	include/intr-stubs.h	2;"	d
_INTSIZEOF	include/stdarg.h	7;"	d
_SWITCH_H_	include/proc/switch.h	2;"	d
__ATA_H__	include/device/ata.h	2;"	d
__BITMAP_H__	include/bitmap.h	2;"	d
__BLOCK_H__	include/device/block.h	2;"	d
__CONSOLE_H__	include/device/console.h	2;"	d
__DEVICE_H__	include/device/device.h	2;"	d
__DO_SYSCALL_H__	include/do_syscall.h	2;"	d
__INODE_H__	include/filesys/inode.h	2;"	d
__INTERRUPT_H__	include/interrupt.h	2;"	d
__IO_H__	include/device/io.h	2;"	d
__IO_H__	include/device/io2.h	2;"	d
__KDB_H__	include/device/kbd.h	2;"	d
__LIB_CTYPE_H	include/ctype.h	2;"	d
__LIB_DEBUG_H	include/debug.h	2;"	d
__LIB_INTTYPES_H	include/inttypes.h	2;"	d
__LIB_PACKED_H	include/packed.h	2;"	d
__LIB_ROUND_H	include/round.h	2;"	d
__LIB_STDBOOL_H	include/stdbool.h	2;"	d
__LIB_STDDEF_H	include/stddef.h	2;"	d
__LIB_STDINT_H	include/stdint.h	2;"	d
__LIB_STDIO_H	include/stdio.h	2;"	d
__LIB_STDLIB_H	include/stdlib.h	2;"	d
__LIB_STRING_H	include/string.h	2;"	d
__LIMITS_H__	include/limits.h	2;"	d
__LIST_H__	include/list.h	2;"	d
__MALLOC_H__	include/mem/malloc.h	2;"	d
__MEM_H__	include/mem/mm.h	2;"	d
__PAGING_H__	include/mem/paging.h	2;"	d
__PALLOC_H__	include/mem/palloc.h	2;"	d
__PIT_H__	include/device/pit.h	2;"	d
__PROC_H__	include/proc/proc.h	2;"	d
__SCHED_H__	include/proc/sched.h	2;"	d
__SSULIB_H__	include/ssulib.h	2;"	d
__SSU_FILE_H__	include/filesys/file.h	2;"	d
__SSU_FS_H__	include/filesys/fs.h	2;"	d
__STDARG_H__	include/stdarg.h	2;"	d
__SYNCH_H__	include/synch.h	2;"	d
__SYSCALL_H__	include/syscall.h	2;"	d
__TYPE_H__	include/type.h	2;"	d
__bool_true_false_are_defined	include/stdbool.h	7;"	d
__printf	stdio.c	/^__printf (const char *format,$/;"	f
__vprintf	stdio.c	/^__vprintf (const char *format, va_list args,$/;"	f
a_s	device/console.c	/^bool a_s = TRUE;$/;"	v
arch	Makefile	/^arch = .\/arch$/;"	m
archx86	Makefile	/^archx86 = .\/arch\/i386$/;"	m
ata	include/device/ata.h	/^struct ata_interface ata;$/;"	v	typeref:struct:ata_interface
ata0_blk_dev	include/device/ata.h	/^struct blk_dev ata0_blk_dev;$/;"	v	typeref:struct:blk_dev
ata0_blk_dev	include/device/block.h	/^struct blk_dev ata0_blk_dev;$/;"	v	typeref:struct:blk_dev
ata1_blk_dev	include/device/ata.h	/^struct blk_dev ata1_blk_dev;$/;"	v	typeref:struct:blk_dev
ata1_blk_dev	include/device/block.h	/^struct blk_dev ata1_blk_dev;$/;"	v	typeref:struct:blk_dev
ata_cmd	device/ata.c	/^ata_cmd(struct ata_device *device, uint8_t command)$/;"	f	file:
ata_device	include/device/ata.h	/^struct ata_device$/;"	s
ata_interface	include/device/ata.h	/^struct ata_interface$/;"	s
ata_io_ready	device/ata.c	/^ata_io_ready (struct ata_device *d, blk_sec_t sec_num)$/;"	f	file:
ata_ops	device/ata.c	/^static struct blk_dev_ops ata_ops =$/;"	v	typeref:struct:blk_dev_ops	file:
ata_read	device/ata.c	/^ata_read (void *dev, blk_sec_t sec_num, void *buf)$/;"	f	file:
ata_write	device/ata.c	/^ata_write (void *dev, blk_sec_t sec_num, const void *buf)$/;"	f	file:
bAtt	include/device/console.h	/^		unsigned char bAtt;$/;"	m	struct:kChStruct
bCh	include/device/console.h	/^		unsigned char bCh;$/;"	m	struct:kChStruct
balloc	filesys/fs.c	/^balloc(struct bitmap *b, unsigned *index)$/;"	f
barrier	include/synch.h	50;"	d
base	mem/palloc.c	/^	uint32_t *base;                      \/* Base of pool. *\/$/;"	m	struct:pool	file:
base	stdio.c	/^    int base;                   \/* Base. *\/$/;"	m	struct:integer_base	file:
base_X	stdio.c	/^static const struct integer_base base_X = {16, "0123456789ABCDEF", 'X', 4};$/;"	v	typeref:struct:integer_base	file:
base_d	stdio.c	/^static const struct integer_base base_d = {10, "0123456789", 0, 3};$/;"	v	typeref:struct:integer_base	file:
base_o	stdio.c	/^static const struct integer_base base_o = {8, "01234567", 0, 3};$/;"	v	typeref:struct:integer_base	file:
base_x	stdio.c	/^static const struct integer_base base_x = {16, "0123456789abcdef", 'x', 4};$/;"	v	typeref:struct:integer_base	file:
bit_cnt	include/bitmap.h	/^	size_t bit_cnt;     \/* Number of bits. *\/$/;"	m	struct:bitmap
bit_mask	bitmap.c	/^bit_mask (size_t bit_idx) $/;"	f	file:
bitmap	include/bitmap.h	/^struct bitmap$/;"	s
bitmap_all	bitmap.c	/^bitmap_all (const struct bitmap *b, size_t start, size_t cnt) $/;"	f
bitmap_any	bitmap.c	/^bitmap_any (const struct bitmap *b, size_t start, size_t cnt) $/;"	f
bitmap_buf_size	bitmap.c	/^bitmap_buf_size (size_t bit_cnt) $/;"	f
bitmap_contains	bitmap.c	/^bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) $/;"	f
bitmap_count	bitmap.c	/^bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) $/;"	f
bitmap_create_in_buf	bitmap.c	/^bitmap_create_in_buf (size_t bit_cnt, void *block, size_t block_size)\/\/ UNUSED)$/;"	f
bitmap_file_size	bitmap.c	/^bitmap_file_size (const struct bitmap *b) $/;"	f
bitmap_flip	bitmap.c	/^bitmap_flip (struct bitmap *b, size_t bit_idx) $/;"	f
bitmap_mark	bitmap.c	/^bitmap_mark (struct bitmap *b, size_t bit_idx) $/;"	f
bitmap_none	bitmap.c	/^bitmap_none (const struct bitmap *b, size_t start, size_t cnt) $/;"	f
bitmap_read	bitmap.c	/^bitmap_read (struct bitmap *b, struct file *file) $/;"	f
bitmap_reset	bitmap.c	/^bitmap_reset (struct bitmap *b, size_t bit_idx) $/;"	f
bitmap_scan	bitmap.c	/^bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) $/;"	f
bitmap_scan_and_flip	bitmap.c	/^bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)$/;"	f
bitmap_set	bitmap.c	/^bitmap_set (struct bitmap *b, size_t idx, bool value) $/;"	f
bitmap_set_all	bitmap.c	/^bitmap_set_all (struct bitmap *b, bool value) $/;"	f
bitmap_set_multiple	bitmap.c	/^bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) $/;"	f
bitmap_size	bitmap.c	/^bitmap_size (const struct bitmap *b)$/;"	f
bitmap_test	bitmap.c	/^bitmap_test (const struct bitmap *b, size_t idx) $/;"	f
bitmap_write	bitmap.c	/^bitmap_write (const struct bitmap *b, struct file *file)$/;"	f
bitmapblock	filesys/fs.c	/^static unsigned char bitmapblock[SSU_BLOCK_SIZE];$/;"	v	file:
bits	include/bitmap.h	/^	elem_type *bits;    \/* Elements that represent bits. *\/$/;"	m	struct:bitmap
blk_cnt_t	include/device/block.h	/^typedef uint32_t blk_cnt_t;$/;"	t
blk_count	include/device/block.h	/^    blk_cnt_t blk_count;$/;"	m	struct:blk_dev
blk_dev	include/device/block.h	/^struct blk_dev$/;"	s
blk_dev_ops	include/device/block.h	/^struct blk_dev_ops$/;"	s
blk_dev_read	device/block.c	/^blk_dev_read (struct blk_dev *blk_dev, blk_sec_t sector, void *buf)$/;"	f
blk_dev_register	device/block.c	/^void blk_dev_register (struct blk_dev * blk_dev, blk_dev_t type,$/;"	f
blk_dev_t	include/device/block.h	/^typedef uint32_t blk_dev_t;$/;"	t
blk_dev_write	device/block.c	/^blk_dev_write (struct blk_dev *blk_dev, blk_sec_t sector, const void *buf)$/;"	f
blk_sec_t	include/device/block.h	/^typedef uint32_t blk_sec_t;$/;"	t
blk_size	include/device/block.h	/^    blk_size_t blk_size;                 $/;"	m	struct:blk_dev
blk_size_t	include/device/block.h	/^typedef uint32_t blk_size_t;$/;"	t
bool	include/type.h	/^typedef char bool;$/;"	t
buf_e	device/console.c	25;"	d	file:
buf_head	device/kbd.c	/^int buf_head, buf_tail;$/;"	v
buf_p	device/console.c	/^char *buf_p;	$/;"	v
buf_s	device/console.c	/^char buf_s[SIZE_SCROLL]; $/;"	v
buf_tail	device/kbd.c	/^int buf_head, buf_tail;$/;"	v
buf_w	device/console.c	/^char *buf_w;	$/;"	v
byte_cnt	bitmap.c	/^byte_cnt (size_t bit_cnt)$/;"	f	file:
cat_proc	proc/proc.c	/^void cat_proc(void *aux)$/;"	f
change_dir	filesys/inode.c	/^int change_dir(struct inode *cwd, char *path)$/;"	f
child_pid	include/proc/proc.h	/^	int child_pid;						\/\/ 종료된 자식$/;"	m	struct:process
clrScreen	device/console.c	/^void clrScreen(void) $/;"	f
clr_tmp_block	device/ata.c	/^void clr_tmp_block(void)$/;"	f
cmd	proc/proc.c	/^	char* cmd;$/;"	m	struct:__anon1	file:
condition	include/synch.h	/^struct condition $/;"	s
cs	include/interrupt.h	/^	uint16_t cs, :16;           \/* Code segment for eip. *\/$/;"	m	struct:intr_frame
cur_process	proc/proc.c	/^struct process *cur_process;$/;"	v	typeref:struct:process
cwd	include/proc/proc.h	/^	struct inode * cwd;$/;"	m	struct:process	typeref:struct:process::inode
d_list	proc/proc.c	/^struct list d_list;		\/\/ Deleted Process List$/;"	v	typeref:struct:list
de_ino	include/filesys/inode.h	/^	uint32_t de_ino;			\/* Inode number *\/$/;"	m	struct:direntry
de_name	include/filesys/inode.h	/^	char de_name[FILENAME_LEN];		\/* Filename *\/$/;"	m	struct:direntry
default_handler	arch/interrupt.c	/^void default_handler(struct intr_frame *iframe)$/;"	f
delay_ata_for	device/ata.c	/^delay_ata_for(struct ata_device *device, int what_for)$/;"	f	file:
detect_mem	mem/mm.c	/^void detect_mem()$/;"	f
dev_shutdown	device/device.c	/^void dev_shutdown(void)$/;"	f
device	Makefile	/^device = .\/device$/;"	m
device_info	include/device/block.h	/^    void *device_info;                        \/* Extra data owned by driver. *\/$/;"	m	struct:blk_dev
digits	stdio.c	/^    const char *digits;         \/* Collection of digits. *\/$/;"	m	struct:integer_base	file:
direntry	include/filesys/inode.h	/^struct direntry {$/;"	s
disk_handler	device/ata.c	/^disk_handler (struct intr_frame *iframe) $/;"	f	file:
do_div	vsprintk.c	13;"	d	file:
do_exit	arch/do_syscall.c	/^void do_exit(int status)$/;"	f
do_fork	arch/do_syscall.c	/^pid_t do_fork(proc_func func, void* aux1, void* aux2)$/;"	f
do_open	arch/do_syscall.c	/^int do_open(const char *pathname, int flags)$/;"	f
do_read	arch/do_syscall.c	/^int do_read(int fd, char *buf, int len)$/;"	f
do_sched_on_return	arch/interrupt.c	/^void do_sched_on_return(void)$/;"	f
do_shutdown	arch/do_syscall.c	/^void do_shutdown(void)$/;"	f
do_ssuread	arch/do_syscall.c	/^int do_ssuread(void)$/;"	f
do_wait	arch/do_syscall.c	/^pid_t do_wait(int *status)$/;"	f
do_write	arch/do_syscall.c	/^int do_write(int fd, const char *buf, int len)$/;"	f
ds	include/interrupt.h	/^	uint16_t ds, :16;           \/* Saved DS segment register. *\/$/;"	m	struct:intr_frame
eax	include/interrupt.h	/^	uint32_t eax;               \/* Saved EAX. *\/$/;"	m	struct:intr_frame
ebp	include/interrupt.h	/^	uint32_t ebp;               \/* Saved EBP. *\/$/;"	m	struct:intr_frame
ebx	include/interrupt.h	/^	uint32_t ebx;               \/* Saved EBX. *\/$/;"	m	struct:intr_frame
ecx	include/interrupt.h	/^	uint32_t ecx;               \/* Saved ECX. *\/$/;"	m	struct:intr_frame
edi	include/interrupt.h	/^	uint32_t edi;               \/* Saved EDI. *\/$/;"	m	struct:intr_frame
edx	include/interrupt.h	/^	uint32_t edx;               \/* Saved EDX. *\/$/;"	m	struct:intr_frame
eflags	include/interrupt.h	/^	uint32_t eflags;            \/* Saved CPU flags. *\/$/;"	m	struct:intr_frame
eip	include/interrupt.h	/^	void (*eip) (void);         \/* Next instruction to execute. *\/$/;"	m	struct:intr_frame
elem_all	include/proc/proc.h	/^	struct list_elem elem_all;		\/\/프로세스 전체 리스트 노드$/;"	m	struct:process	typeref:struct:process::list_elem
elem_cnt	bitmap.c	/^elem_cnt (size_t bit_cnt)$/;"	f	file:
elem_idx	bitmap.c	/^elem_idx (size_t bit_idx) $/;"	f	file:
elem_stat	include/proc/proc.h	/^	struct list_elem elem_stat;		\/\/프로세스 상태 별 리스트 노드$/;"	m	struct:process	typeref:struct:process::list_elem
elem_type	include/bitmap.h	/^typedef unsigned long elem_type;$/;"	t
error_code	include/interrupt.h	/^	uint32_t error_code;        \/* Error code. *\/$/;"	m	struct:intr_frame
es	include/interrupt.h	/^	uint16_t es, :16;           \/* Saved ES segment register. *\/$/;"	m	struct:intr_frame
esi	include/interrupt.h	/^	uint32_t esi;               \/* Saved ESI. *\/$/;"	m	struct:intr_frame
esp	include/interrupt.h	/^	void *esp;                  \/* Saved stack pointer. *\/$/;"	m	struct:intr_frame
esp_dummy	include/interrupt.h	/^	uint32_t esp_dummy;         \/* Not used. *\/$/;"	m	struct:intr_frame
exit	arch/syscall.c	/^void exit(int status)$/;"	f
exit_status	include/proc/proc.h	/^	int exit_status;					\/\/ 종료 상태$/;"	m	struct:process
false	include/stdbool.h	6;"	d
false	include/type.h	22;"	d
file	include/proc/proc.h	/^	struct ssufile *file[NR_FILEDES];$/;"	m	struct:process	typeref:struct:process::ssufile
file_open	filesys/file.c	/^int file_open(struct inode *inode, int flags, int mode)$/;"	f
file_read	filesys/file.c	/^int file_read(struct inode *inode, size_t offset, void *buf, size_t len)$/;"	f
file_write	filesys/file.c	/^int file_write(struct inode *inode, size_t offset, void *buf, size_t len)$/;"	f
filesys	Makefile	/^filesys = .\/filesys$/;"	m
filesys	include/filesys/fs.h	/^static struct ssu_fs filesys;$/;"	v	typeref:struct:ssu_fs
find_end_of_run	list.c	/^find_end_of_run (struct list_elem *a, struct list_elem *b,$/;"	f	file:
flags	include/filesys/file.h	/^	uint8_t flags;$/;"	m	struct:ssufile
flags	stdio.c	/^    flags;$/;"	m	struct:printf_conversion	typeref:enum:printf_conversion::__anon2	file:
fork	arch/syscall.c	/^pid_t fork(proc_func func, void* aux1, void* aux2)$/;"	f
format_integer	stdio.c	/^format_integer (unsigned int value, bool is_signed, bool negative, $/;"	f	file:
format_string	stdio.c	/^format_string (const char *string, int length,$/;"	f	file:
frame_pointer	include/interrupt.h	/^	void *frame_pointer;        \/* Saved EBP (frame pointer). *\/$/;"	m	struct:intr_frame
fs	include/interrupt.h	/^	uint16_t fs, :16;           \/* Saved FS segment register. *\/$/;"	m	struct:intr_frame
fs_blkmap	include/filesys/fs.h	/^	struct bitmap *fs_blkmap;$/;"	m	struct:ssu_fs	typeref:struct:ssu_fs::bitmap
fs_device	include/filesys/fs.h	/^	struct blk_dev *fs_device;$/;"	m	struct:ssu_fs	typeref:struct:ssu_fs::blk_dev
fs_inodemap	include/filesys/fs.h	/^	struct bitmap *fs_inodemap;$/;"	m	struct:ssu_fs	typeref:struct:ssu_fs::bitmap
fs_mount	filesys/fs.c	/^fs_mount(struct ssu_fs *fs, struct blk_dev *dev)$/;"	f
fs_readblock	filesys/fs.c	/^int fs_readblock(struct ssu_fs *fs, uint32_t blknum, char *buf)$/;"	f
fs_sb	include/filesys/fs.h	/^	struct ssu_superblock fs_sb;$/;"	m	struct:ssu_fs	typeref:struct:ssu_fs::ssu_superblock
fs_writeblock	filesys/fs.c	/^int fs_writeblock(struct ssu_fs *fs, uint32_t blknum, const char *buf)$/;"	f
func	proc/proc.c	/^	void* func;$/;"	m	struct:__anon1	file:
generic_read	ssulib.c	/^int generic_read(int fd, void *buf, size_t len)$/;"	f
generic_write	ssulib.c	/^int generic_write(int fd, void *buf, size_t len)$/;"	f
getEIP	proc/proc.c	/^void* getEIP()$/;"	f
getMemSize	arch/i386/mem.asm	/^getMemSize:		$/;"	l
getToken	ssulib.c	/^int getToken(char* buf, char token[][BUFSIZ], int max_tok)$/;"	f
getValidPid	proc/proc.c	/^pid_t getValidPid(int *idx) {$/;"	f
get_cur_pd	mem/paging.c	/^uint32_t* get_cur_pd()$/;"	f
get_curde	filesys/inode.c	/^int get_curde(struct inode *cwd, struct direntry * de)$/;"	f
get_next_proc	proc/sched.c	/^struct process* get_next_proc(void) {$/;"	f
get_ticks	arch/interrupt.c	/^unsigned long get_ticks(void)$/;"	f
getkbd	ssulib.c	/^bool getkbd(char *buf, int len) $/;"	f
group	stdio.c	/^    int group;                  \/* Number of digits to group with ' flag. *\/$/;"	m	struct:integer_base	file:
gs	include/interrupt.h	/^	uint16_t gs, :16;           \/* Saved GS segment register. *\/$/;"	m	struct:intr_frame
handlers	arch/interrupt.c	/^intr_handler_func *handlers[INTR_MAX];	\/\/실제 인터럽트 핸들러 들$/;"	v
head	include/list.h	/^    struct list_elem head;      \/* List head. *\/$/;"	m	struct:list	typeref:struct:list::list_elem
hexDump	proc/proc.c	/^void hexDump (void *addr, int len) {$/;"	f
hex_dump	stdio.c	/^hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)$/;"	f
holder	include/synch.h	/^      struct process *holder;      \/* Process holding lock (for debugging). *\/$/;"	m	struct:lock	typeref:struct:lock::process
idle	include/proc/proc.h	/^proc_func idle;						\/\/idle 함수$/;"	v
idle	proc/proc.c	/^void idle(void* aux)$/;"	f
idt	arch/interrupt.c	/^_ID     *idt;$/;"	v
in_external_intr	arch/interrupt.c	/^static bool in_external_intr;   \/* Are we processing an external interrupt? *\/$/;"	v	file:
inb	arch/i386/io.asm	/^inb:$/;"	l
init_ata	device/ata.c	/^init_ata(void) $/;"	f
init_console	device/console.c	/^void init_console(void)$/;"	f
init_filesystem	filesys/fs.c	/^void init_filesystem(void)$/;"	f
init_inode_table	filesys/inode.c	/^void init_inode_table(struct ssu_fs *fs)$/;"	f
init_intr	arch/interrupt.c	/^int init_intr(void)$/;"	f
init_kbd	device/kbd.c	/^void init_kbd(void)$/;"	f
init_paging	mem/paging.c	/^void init_paging()$/;"	f
init_palloc	mem/palloc.c	/^init_palloc (void) $/;"	f
init_pit	device/pit.c	/^void init_pit(void)  $/;"	f
init_pool	mem/palloc.c	/^init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) $/;"	f	file:
init_proc	proc/proc.c	/^void init_proc()$/;"	f
init_syscall	arch/syscall.c	/^void init_syscall(void)$/;"	f
inl	arch/i386/io.asm	/^inl:$/;"	l
inode	include/filesys/file.h	/^	struct inode *inode;$/;"	m	struct:ssufile	typeref:struct:ssufile::inode
inode	include/filesys/inode.h	/^struct inode$/;"	s
inode_create	filesys/inode.c	/^struct inode* inode_create(struct ssu_fs *fs, uint16_t type)$/;"	f
inode_open	filesys/inode.c	/^struct inode *inode_open(const char *pathname)$/;"	f
inode_read	filesys/inode.c	/^int inode_read(struct inode * in, uint32_t offset, char * buf, int len)$/;"	f
inode_tbl	include/filesys/inode.h	/^struct inode inode_tbl[NUM_INODE];$/;"	v	typeref:struct:inode
inode_write	filesys/inode.c	/^int inode_write(struct inode * in, uint32_t offset, char * buf, int len)$/;"	f
inplace_merge	list.c	/^inplace_merge (struct list_elem *a0, struct list_elem *a1b0,$/;"	f	file:
insw	include/device/io.h	/^insw (uint16_t port, void *addr, size_t cnt)$/;"	f
insw	include/device/io2.h	/^insw (uint16_t port, void *addr, size_t cnt)$/;"	f
int16_t	include/stdint.h	/^typedef signed short int int16_t;$/;"	t
int16_t	include/type.h	/^typedef signed short int int16_t;$/;"	t
int32_t	include/stdint.h	/^typedef signed int int32_t;$/;"	t
int32_t	include/type.h	/^typedef signed int int32_t;$/;"	t
int64_t	include/stdint.h	/^typedef signed long long int int64_t;$/;"	t
int64_t	include/type.h	/^typedef signed long long int int64_t;$/;"	t
int8_t	include/stdint.h	/^typedef signed char int8_t;$/;"	t
int8_t	include/type.h	/^typedef signed char int8_t;$/;"	t
integer_base	stdio.c	/^struct integer_base $/;"	s	file:
intmax_t	include/stdint.h	/^typedef int64_t intmax_t;$/;"	t
intmax_t	include/type.h	/^typedef int64_t intmax_t;$/;"	t
intptr_t	include/stdint.h	/^typedef int32_t intptr_t;$/;"	t
intptr_t	include/type.h	/^typedef int32_t intptr_t;$/;"	t
intr_common	arch/interrupt.c	/^void intr_common(struct intr_frame *iframe)$/;"	f
intr_context	arch/interrupt.c	/^bool intr_context (void)$/;"	f
intr_disable	arch/interrupt.c	/^enum intr_level intr_disable (void) $/;"	f
intr_enable	arch/interrupt.c	/^enum intr_level intr_enable (void) $/;"	f
intr_entry	arch/i386/intr-stubs.S	/^intr_entry:$/;"	l
intr_exit	arch/i386/intr-stubs.S	/^intr_exit:$/;"	l
intr_frame	include/interrupt.h	/^struct intr_frame$/;"	s
intr_get_level	arch/interrupt.c	/^enum intr_level intr_get_level (void) $/;"	f
intr_handler_func	include/interrupt.h	/^typedef void intr_handler_func (struct intr_frame *);$/;"	t
intr_level	include/interrupt.h	/^enum intr_level$/;"	g
intr_set_level	arch/interrupt.c	/^enum intr_level intr_set_level (enum intr_level level) $/;"	f
intr_stub_func	include/intr-stubs.h	/^typedef void intr_stub_func (void);$/;"	t
intr_stubs	arch/i386/intr-stubs.S	/^intr_stubs:$/;"	l
inw	include/device/io2.h	/^inw (uint16_t port)$/;"	f
iowait	arch/i386/io.asm	/^iowait:$/;"	l
irq	include/device/ata.h	/^  uint8_t irq;$/;"	m	struct:ata_device
isEmpty	device/kbd.c	/^bool isEmpty()$/;"	f
isFull	device/kbd.c	/^bool isFull()$/;"	f
is_digit	vsprintk.c	11;"	d	file:
is_head	list.c	/^is_head (struct list_elem *elem)$/;"	f	file:
is_interior	list.c	/^is_interior (struct list_elem *elem)$/;"	f	file:
is_kernel_vaddr	include/vaddr.h	/^is_kernel_vaddr (const void *vaddr) $/;"	f
is_sorted	list.c	/^is_sorted (struct list_elem *a, struct list_elem *b,$/;"	f	file:
is_tail	list.c	/^is_tail (struct list_elem *elem)$/;"	f	file:
is_user_vaddr	include/vaddr.h	/^is_user_vaddr (const void *vaddr) $/;"	f
isalnum	include/ctype.h	/^static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }$/;"	f
isalpha	include/ctype.h	/^static inline int isalpha (int c) { return islower (c) || isupper (c); }$/;"	f
isascii	include/ctype.h	/^static inline int isascii (int c) { return c >= 0 && c < 128; }$/;"	f
isblank	include/ctype.h	/^static inline int isblank (int c) { return c == ' ' || c == '\\t'; }$/;"	f
iscntrl	include/ctype.h	/^static inline int iscntrl (int c) { return (c >= 0 && c < 32) || c == 127; }$/;"	f
isdigit	include/ctype.h	/^static inline int isdigit (int c) { return c >= '0' && c <= '9'; }$/;"	f
isgraph	include/ctype.h	/^static inline int isgraph (int c) { return c > 32 && c < 127; }$/;"	f
islower	include/ctype.h	/^static inline int islower (int c) { return c >= 'a' && c <= 'z'; }$/;"	f
isprint	include/ctype.h	/^static inline int isprint (int c) { return c >= 32 && c < 127; }$/;"	f
ispunct	include/ctype.h	/^static inline int ispunct (int c) {$/;"	f
isspace	include/ctype.h	/^static inline int isspace (int c) {$/;"	f
isupper	include/ctype.h	/^static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }$/;"	f
isxdigit	include/ctype.h	/^static inline int isxdigit (int c) {$/;"	f
jump_ata	device/ata.c	/^jump_ata (struct ata_device *device) $/;"	f	file:
kChStruct	include/device/console.h	/^typedef struct kChStruct$/;"	s
kbd_buf	device/kbd.c	/^static char kbd_buf[BUFSIZ];$/;"	v	file:
kbd_handler	device/kbd.c	/^void kbd_handler(struct intr_frame *iframe)$/;"	f
kbd_read_char	device/kbd.c	/^char kbd_read_char()$/;"	f
kernel1_proc	proc/proc.c	/^void kernel1_proc(void* aux)$/;"	f
kernel2_proc	proc/proc.c	/^void kernel2_proc(void* aux)$/;"	f
last_mask	bitmap.c	/^last_mask (const struct bitmap *b) $/;"	f	file:
lately_pid	proc/proc.c	/^static int lately_pid;		\/\/init vaule = -1$/;"	v	file:
length	stdio.c	/^    int length;         \/* Length of output string. *\/$/;"	m	struct:vsnprintf_aux	file:
less_time_sleep	proc/proc.c	/^bool less_time_sleep(const struct list_elem *a, const struct list_elem *b,void *aux)$/;"	f
lib	Makefile	/^lib = .\/lib$/;"	m
list	include/list.h	/^struct list $/;"	s
list_back	list.c	/^list_back (struct list *list)$/;"	f
list_begin	list.c	/^list_begin (struct list *list)$/;"	f
list_elem	include/list.h	/^struct list_elem $/;"	s
list_empty	list.c	/^list_empty (struct list *list)$/;"	f
list_end	list.c	/^list_end (struct list *list)$/;"	f
list_entry	include/list.h	107;"	d
list_front	list.c	/^list_front (struct list *list)$/;"	f
list_head	list.c	/^list_head (struct list *list) $/;"	f
list_init	list.c	/^list_init (struct list *list)$/;"	f
list_insert	list.c	/^list_insert (struct list_elem *before, struct list_elem *elem)$/;"	f
list_insert_ordered	list.c	/^list_insert_ordered (struct list *list, struct list_elem *elem,$/;"	f
list_less_func	include/list.h	/^typedef bool list_less_func (const struct list_elem *a,$/;"	t
list_max	list.c	/^list_max (struct list *list, list_less_func *less, void *aux)$/;"	f
list_min	list.c	/^list_min (struct list *list, list_less_func *less, void *aux)$/;"	f
list_next	list.c	/^list_next (struct list_elem *elem)$/;"	f
list_pop_back	list.c	/^list_pop_back (struct list *list)$/;"	f
list_pop_front	list.c	/^list_pop_front (struct list *list)$/;"	f
list_prev	list.c	/^list_prev (struct list_elem *elem)$/;"	f
list_push_back	list.c	/^list_push_back (struct list *list, struct list_elem *elem)$/;"	f
list_push_front	list.c	/^list_push_front (struct list *list, struct list_elem *elem)$/;"	f
list_rbegin	list.c	/^list_rbegin (struct list *list) $/;"	f
list_remove	list.c	/^list_remove (struct list_elem *elem)$/;"	f
list_rend	list.c	/^list_rend (struct list *list) $/;"	f
list_reverse	list.c	/^list_reverse (struct list *list)$/;"	f
list_segment	filesys/inode.c	/^void list_segment(struct inode *cwd)$/;"	f
list_size	list.c	/^list_size (struct list *list)$/;"	f
list_sort	list.c	/^list_sort (struct list *list, list_less_func *less, void *aux)$/;"	f
list_splice	list.c	/^list_splice (struct list_elem *before,$/;"	f
list_tail	list.c	/^list_tail (struct list *list) $/;"	f
list_unique	list.c	/^list_unique (struct list *list, struct list *duplicates,$/;"	f
lock	include/synch.h	/^struct lock $/;"	s
lock	mem/palloc.c	/^	struct lock lock;                   \/* Mutual exclusion. *\/$/;"	m	struct:pool	typeref:struct:pool::lock	file:
lock_acquire	synch.c	/^lock_acquire (struct lock *lock)$/;"	f
lock_held_by_current_thread	synch.c	/^lock_held_by_current_thread (const struct lock *lock) $/;"	f
lock_init	synch.c	/^lock_init (struct lock *lock)$/;"	f
lock_pid_simple	proc/proc.c	/^static int lock_pid_simple; \/\/1 : lock, 0 : unlock$/;"	v	file:
lock_release	synch.c	/^lock_release (struct lock *lock) $/;"	f
lock_try_acquire	synch.c	/^lock_try_acquire (struct lock *lock)$/;"	f
login_proc	proc/proc.c	/^void login_proc(void* aux)$/;"	f
ls_proc	proc/proc.c	/^void ls_proc(void *aux)$/;"	f
lseek_proc	proc/proc.c	/^void lseek_proc(void *aux , void *filename)$/;"	f
main_init	arch/Main.c	/^void main_init(void)$/;"	f
main_init	build/Main.s	/^main_init:$/;"	l
make_dir	filesys/inode.c	/^int make_dir(struct inode *cwd, char *name)$/;"	f
max_length	stdio.c	/^    int max_length;     \/* Max length of output string. *\/$/;"	m	struct:vsnprintf_aux	file:
mem	Makefile	/^mem = .\/mem$/;"	m
mem_pool	mem/palloc.c	/^static struct pool mem_pool;$/;"	v	typeref:struct:pool	file:
mem_size	mem/mm.c	/^unsigned long mem_size()$/;"	f
memchr	string.c	/^memchr (const void *block_, int ch_, size_t size) $/;"	f
memcmp	string.c	/^memcmp (const void *a_, const void *b_, size_t size) $/;"	f
memcpy	string.c	/^memcpy (void *dst_, const void *src_, size_t size) $/;"	f
memcpy_hard	mem/paging.c	/^void memcpy_hard(void* from, void* to, uint32_t len)$/;"	f
memmove	string.c	/^memmove (void *dst_, const void *src_, size_t size) $/;"	f
memset	string.c	/^memset (void *dst_, int value, size_t size) $/;"	f
more_prio	proc/proc.c	/^bool more_prio(const struct list_elem *a, const struct list_elem *b,void *aux)$/;"	f
nGetMemSize	mem/mm.c	/^unsigned long nGetMemSize()$/;"	f
next	include/list.h	/^    struct list_elem *next;     \/* Next list element. *\/$/;"	m	struct:list_elem	typeref:struct:list_elem::list_elem
next_line	device/console.c	/^char next_line[2]; \/\/"\\r\\n";$/;"	v
nodes	include/device/ata.h	/^  struct ata_device nodes[ATA_DEV_NUM];$/;"	m	struct:ata_interface	typeref:struct:ata_interface::ata_device
num_direntry	filesys/inode.c	/^static int num_direntry(struct inode *in)$/;"	f	file:
number	vsprintk.c	/^static char *number(char * str, int num, int base, int size, int precision, int type)$/;"	f	file:
offsetof	include/ssulib.h	5;"	d
offsetof	include/stddef.h	5;"	d
open	arch/syscall.c	/^int open(const char *pathname, int flags)$/;"	f
open_proc	proc/proc.c	/^void open_proc(void *aux)$/;"	f
ops	include/device/block.h	/^    const struct blk_dev_ops *ops;    $/;"	m	struct:blk_dev	typeref:struct:blk_dev::blk_dev_ops
outb	arch/i386/io.asm	/^outb:  $/;"	l
outl	arch/i386/io.asm	/^outl:$/;"	l
output_dup	stdio.c	/^output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) $/;"	f	file:
outsw	include/device/io.h	/^outsw (uint16_t port, const void *addr, size_t cnt)$/;"	f
outsw	include/device/io2.h	/^outsw (uint16_t port, const void *addr, size_t cnt)$/;"	f
p	stdio.c	/^    char *p;            \/* Current output position. *\/$/;"	m	struct:vsnprintf_aux	file:
p_list	proc/proc.c	/^struct list p_list;		\/\/ All Porcess List$/;"	v	typeref:struct:list
p_state	include/proc/proc.h	/^enum p_state {$/;"	g
padding	include/filesys/fs.h	/^	uint32_t padding;$/;"	m	struct:ssu_superblock
palloc_free_multiple	mem/palloc.c	/^palloc_free_multiple (void *pages, size_t page_cnt) $/;"	f
palloc_free_page	mem/palloc.c	/^palloc_free_page (void *page) $/;"	f
palloc_get_multiple	mem/palloc.c	/^palloc_get_multiple (size_t page_cnt)$/;"	f
palloc_get_page	mem/palloc.c	/^palloc_get_page (void) $/;"	f
parent	include/proc/proc.h	/^	struct process* parent;				\/\/ 부모 프로세스$/;"	m	struct:process	typeref:struct:process::process
parse_conversion	stdio.c	/^parse_conversion (const char *format, struct printf_conversion *c,$/;"	f	file:
pd	include/proc/proc.h	/^	void *pd;						\/\/page directory$/;"	m	struct:process
pd_copy	mem/paging.c	/^void pd_copy(uint32_t* from, uint32_t* to, uint32_t* start, uint32_t* end, bool share)$/;"	f
pd_create	mem/paging.c	/^uint32_t* pd_create (pid_t pid)$/;"	f
pde_idx_addr	mem/paging.c	/^uint32_t pde_idx_addr(uint32_t* addr)$/;"	f
pf_handler	mem/paging.c	/^intr_handler_func pf_handler;$/;"	v
pf_handler	mem/paging.c	/^void pf_handler(struct intr_frame *iframe)$/;"	f
pg_addr	mem/paging.c	/^uint32_t* pg_addr(uint32_t* addr)$/;"	f
pg_no	include/mem/paging.h	/^static inline uint32_t pg_no(const uint32_t *page){$/;"	f
pg_no	include/vaddr.h	/^static inline uintptr_t pg_no (const void *va) {$/;"	f
pg_ofs	include/vaddr.h	/^static inline unsigned pg_ofs (const void *va) {$/;"	f
pg_round_down	include/vaddr.h	/^static inline void *pg_round_down (const void *va) {$/;"	f
pg_round_up	include/vaddr.h	/^static inline void *pg_round_up (const void *va) {$/;"	f
pid	include/proc/proc.h	/^	pid_t pid;						\/\/process id$/;"	m	struct:process
pid_num_max	proc/proc.c	/^int pid_num_max;$/;"	v
pid_t	include/proc/proc.h	/^typedef int pid_t;$/;"	t
pool	mem/palloc.c	/^struct pool$/;"	s	file:
port_addr	include/device/ata.h	/^  uint16_t port_addr;$/;"	m	struct:ata_device
pos	include/filesys/file.h	/^	uint16_t pos;$/;"	m	struct:ssufile
precision	stdio.c	/^    int precision;$/;"	m	struct:printf_conversion	file:
prev	include/list.h	/^    struct list_elem *prev;     \/* Previous list element. *\/$/;"	m	struct:list_elem	typeref:struct:list_elem::list_elem
printCharToSerial	device/console.c	/^void printCharToSerial(const char *pString)$/;"	f
print_contributors	arch/Main.c	/^void print_contributors(void)$/;"	f
print_contributors	build/Main.s	/^print_contributors:$/;"	l
print_hex	device/ata.c	/^ print_hex(char buf[], blk_sec_t sec_num, int len) {$/;"	f	file:
print_human_readable_size	stdio.c	/^print_human_readable_size (uint64_t size) $/;"	f
print_pid	include/proc/proc.h	/^proc_func print_pid;				\/\/디버그용, pid 출력$/;"	v
print_pid	proc/proc.c	/^void print_pid(void* aux) {$/;"	f
printf	stdio.c	/^printf (const char *format, ...) $/;"	f
printf_conversion	stdio.c	/^struct printf_conversion $/;"	s	file:
printk	device/console.c	/^int printk(const char *fmt, ...)$/;"	f
priority	include/proc/proc.h	/^	unsigned char priority;			\/\/프로세스의 스케쥴링 우선순위 0~256$/;"	m	struct:process
priority	include/proc/proc.h	/^	unsigned priority;$/;"	m	struct:proc_option
proc	Makefile	/^proc = .\/proc$/;"	m
proc_block	proc/proc.c	/^void proc_block(void)$/;"	f
proc_create	proc/proc.c	/^pid_t proc_create(proc_func func, struct proc_option *opt, void* aux, void* aux2)$/;"	f
proc_end	proc/proc.c	/^void proc_end(void)$/;"	f
proc_free	proc/proc.c	/^void proc_free(void)$/;"	f
proc_func	include/proc/proc.h	/^typedef void proc_func(void* aux);	\/\/process 동작 함수 원형$/;"	t
proc_option	include/proc/proc.h	/^struct proc_option$/;"	s
proc_print_data	proc/proc.c	/^void proc_print_data()$/;"	f
proc_sleep	proc/proc.c	/^void proc_sleep(unsigned ticks)$/;"	f
proc_start	proc/proc.c	/^void  proc_start(void)$/;"	f
proc_unblock	proc/proc.c	/^void proc_unblock(struct process* proc)$/;"	f
proc_wake	proc/proc.c	/^void proc_wake(void)$/;"	f
process	include/proc/proc.h	/^struct process$/;"	s
process_stack_ofs	proc/proc.c	/^uint32_t process_stack_ofs;$/;"	v
procs	proc/proc.c	/^struct process procs[PROC_NUM_MAX];$/;"	v	typeref:struct:process
ps_proc	proc/proc.c	/^void ps_proc(void* aux)$/;"	f
pt_addr	mem/paging.c	/^uint32_t* pt_addr(uint32_t* addr)$/;"	f
pt_copy	mem/paging.c	/^uint32_t pt_copy(uint32_t *pd, uint32_t *dest_pd, uint32_t idx, uint32_t* start, uint32_t* end, bool share)$/;"	f
pt_pde	mem/paging.c	/^uint32_t* pt_pde(uint32_t pde)$/;"	f
pte_idx_addr	mem/paging.c	/^uint32_t pte_idx_addr(uint32_t* addr)$/;"	f
ptov	include/vaddr.h	/^ptov (uintptr_t paddr)$/;"	f
ptrdiff_t	include/stddef.h	/^typedef __PTRDIFF_TYPE__ ptrdiff_t;$/;"	t
qword	include/type.h	/^typedef long long qword;$/;"	t
r_list	proc/proc.c	/^struct list r_list;		\/\/ Run Porcess List$/;"	v	typeref:struct:list
read	arch/syscall.c	/^int read(int fd, char *buf, size_t len)$/;"	f
read	include/device/block.h	/^  void (*read) (void *blk_dev, blk_sec_t, void *buf);$/;"	m	struct:blk_dev_ops
read_cr0	arch/i386/crset.asm	/^read_cr0:$/;"	l
read_cr3	arch/i386/crset.asm	/^read_cr3:$/;"	l
refreshScreen	device/console.c	/^void refreshScreen(void)$/;"	f
reg_handler	arch/interrupt.c	/^void reg_handler(unsigned short idx, intr_handler_func *handler) $/;"	f
rootdir	include/proc/proc.h	/^	struct inode * rootdir;$/;"	m	struct:process	typeref:struct:process::inode
s_list	proc/proc.c	/^struct list s_list;		\/\/ Sleep Process List$/;"	v	typeref:struct:list
sb_magic	include/filesys/fs.h	/^	uint32_t sb_magic;					$/;"	m	struct:ssu_superblock
sb_nblocks	include/filesys/fs.h	/^	uint32_t sb_nblocks;$/;"	m	struct:ssu_superblock
sb_volname	include/filesys/fs.h	/^	char sb_volname[VOLNAME_LEN];$/;"	m	struct:ssu_superblock
scale_down	mem/paging.c	/^uint32_t scale_down(uint32_t base, uint32_t size)$/;"	f
scale_up	mem/paging.c	/^uint32_t scale_up(uint32_t base, uint32_t size)$/;"	f
sched_on_return	arch/interrupt.c	/^bool sched_on_return;		\/\/인터럽트가 끝날 때 schedule 할 지 결정$/;"	v
schedule	proc/sched.c	/^void schedule(void)$/;"	f
scroll	device/console.c	/^void scroll(void) $/;"	f
scroll_screen	device/console.c	/^void scroll_screen(int offset)$/;"	f
sector_read	device/ata.c	/^sector_read (struct ata_device *device, void *sector) $/;"	f	file:
sector_write	device/ata.c	/^sector_write (struct ata_device *device, const void *sector) $/;"	f	file:
sema	include/device/ata.h	/^  struct semaphore sema;$/;"	m	struct:ata_device	typeref:struct:ata_device::semaphore
sema_down	synch.c	/^sema_down (struct semaphore *sema) $/;"	f
sema_init	synch.c	/^sema_init(struct semaphore *sema, unsigned value)$/;"	f
sema_self_test	synch.c	/^sema_self_test (void) $/;"	f
sema_test_helper	synch.c	/^sema_test_helper (void *sema_) $/;"	f	file:
sema_try_down	synch.c	/^sema_try_down (struct semaphore *sema) $/;"	f
sema_up	synch.c	/^sema_up (struct semaphore *sema) $/;"	f
semaphore	include/synch.h	/^      struct semaphore semaphore; \/* Binary semaphore controlling access. *\/$/;"	m	struct:lock	typeref:struct:lock::semaphore
semaphore	include/synch.h	/^struct semaphore $/;"	s
set_cursor	device/console.c	/^void set_cursor(void)$/;"	f
set_fallow	device/console.c	/^void set_fallow(void)$/;"	f
set_volname	filesys/fs.c	/^set_volname(struct ssu_superblock *sb, const char *name)$/;"	f	file:
shell_proc	proc/proc.c	/^void shell_proc(void* aux)$/;"	f
shutdown	arch/syscall.c	/^void shutdown(void)$/;"	f
simple_lock	include/proc/proc.h	/^	int simple_lock;					\/\/ 부모 락$/;"	m	struct:process
size_t	include/stddef.h	/^typedef __SIZE_TYPE__ size_t;$/;"	t
size_t	include/type.h	/^typedef unsigned size_t;$/;"	t
skip_atoi	vsprintk.c	/^static int skip_atoi(const char **s)$/;"	f	file:
sn_directblock	include/filesys/inode.h	/^	uint32_t sn_directblock[NUM_DIRECT];	\/\/ index of data block$/;"	m	struct:inode
sn_fs	include/filesys/inode.h	/^	struct ssu_fs * sn_fs;							\/\/ filesystem of inode$/;"	m	struct:inode	typeref:struct:inode::ssu_fs
sn_ino	include/filesys/inode.h	/^	uint32_t sn_ino;						\/\/ inode number. In SSU-FS, i-number is inode-table index$/;"	m	struct:inode
sn_nlink	include/filesys/inode.h	/^	uint16_t sn_nlink;						\/\/ number of using direct block$/;"	m	struct:inode
sn_padding	include/filesys/inode.h	/^	uint32_t sn_padding;					\/\/ unused$/;"	m	struct:inode
sn_refcount	include/filesys/inode.h	/^	uint32_t sn_refcount; 					\/\/ open count$/;"	m	struct:inode
sn_size	include/filesys/inode.h	/^	uint32_t sn_size;						\/\/ file size(Byte)$/;"	m	struct:inode
sn_type	include/filesys/inode.h	/^	uint16_t sn_type;						\/\/ file type$/;"	m	struct:inode
snprintf	stdio.c	/^snprintf (char *buffer, size_t buf_size, const char *format, ...) $/;"	f
sprintf	include/stdio.h	37;"	d
ss	include/interrupt.h	/^	uint16_t ss, :16;           \/* Data segment for esp. *\/$/;"	m	struct:intr_frame
ssu_fs	include/filesys/fs.h	/^struct ssu_fs{$/;"	s
ssu_superblock	include/filesys/fs.h	/^struct ssu_superblock{$/;"	s
ssufile	include/filesys/file.h	/^struct ssufile {$/;"	s
ssuos_main	arch/Main.c	/^void ssuos_main(void)$/;"	f
ssuos_main	build/Main.s	/^ssuos_main:$/;"	l
ssuread	arch/syscall.c	/^int ssuread()$/;"	f
stack	include/proc/proc.h	/^	void *stack;					\/\/stack for esp$/;"	m	struct:process
state	include/proc/proc.h	/^	enum p_state state;				\/\/ process state$/;"	m	struct:process	typeref:enum:process::p_state
strcat	include/string.h	31;"	d
strchr	string.c	/^strchr (const char *string, int c_) $/;"	f
strcmp	string.c	/^strcmp (const char *a_, const char *b_) $/;"	f
strcpy	include/string.h	29;"	d
strcspn	string.c	/^strcspn (const char *string, const char *stop) $/;"	f
strlcat	string.c	/^strlcat (char *dst, const char *src, size_t size) $/;"	f
strlcpy	string.c	/^strlcpy (char *dst, const char *src, size_t size) $/;"	f
strlen	vsprintk.c	/^int strlen(const char *string)$/;"	f
strncat	include/string.h	32;"	d
strncmp	ssulib.c	/^int strncmp(char* b1, char* b2, int len)$/;"	f
strncpy	include/string.h	30;"	d
strnlen	string.c	/^strnlen (const char *string, size_t maxlen) $/;"	f
strpbrk	string.c	/^strpbrk (const char *string, const char *stop) $/;"	f
strrchr	string.c	/^strrchr (const char *string, int c_) $/;"	f
strspn	string.c	/^strspn (const char *string, const char *skip) $/;"	f
strstr	string.c	/^strstr (const char *haystack, const char *needle) $/;"	f
strtok	include/string.h	33;"	d
strtok_r	string.c	/^strtok_r (char *s, const char *delimiters, char **save_ptr) $/;"	f
sum_y	device/console.c	/^int sum_y;$/;"	v
swap	list.c	/^swap (struct list_elem **a, struct list_elem **b) $/;"	f	file:
switch_process	arch/i386/switch.S	/^switch_process:$/;"	l
sync_bitmapblock	filesys/fs.c	/^sync_bitmapblock(struct ssu_fs *fs)$/;"	f
sync_inode	filesys/inode.c	/^static int sync_inode(struct ssu_fs *fs, struct inode* inode)$/;"	f	file:
sync_ssufs	filesys/fs.c	/^sync_ssufs(struct ssu_fs *fs, const char* inodes, const char* superblock)$/;"	f	file:
sync_superblock	filesys/fs.c	/^sync_superblock(struct ssu_fs *fs, const char* superblock)$/;"	f	file:
syscall0	arch/syscall.c	11;"	d	file:
syscall1	arch/syscall.c	23;"	d	file:
syscall2	arch/syscall.c	37;"	d	file:
syscall3	arch/syscall.c	53;"	d	file:
syscall_handler	arch/interrupt.c	/^void syscall_handler(struct intr_frame *iframe)$/;"	f
syscall_tbl	arch/syscall.c	/^int syscall_tbl[SYS_NUM][2];$/;"	v
tail	include/list.h	/^    struct list_elem tail;      \/* List tail. *\/$/;"	m	struct:list	typeref:struct:list::list_elem
ticks	arch/interrupt.c	/^static unsigned long ticks;$/;"	v	file:
time_sched	include/proc/proc.h	/^	unsigned long long time_sched;		\/\/ 스케줄 횟수$/;"	m	struct:process
time_sleep	include/proc/proc.h	/^	unsigned long long time_sleep;	\/\/프로세스를 재울 시간$/;"	m	struct:process
time_slice	include/proc/proc.h	/^	unsigned time_slice;			\/\/프로세스의 수행 tick. 스케줄 시 초기화$/;"	m	struct:process
time_used	include/proc/proc.h	/^	unsigned long long time_used;		\/\/ 총 실행 시간$/;"	m	struct:process
timer_handler	arch/interrupt.c	/^void timer_handler(struct intr_frame *iframe)$/;"	f
tmp_block	device/ata.c	/^unsigned char tmp_block[ATA_SECOR_SIZE] = {0, };$/;"	v
tmpblock	filesys/inode.c	/^char tmpblock[SSU_BLOCK_SIZE];$/;"	v
tolower	include/ctype.h	/^static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }$/;"	f
toupper	include/ctype.h	/^static inline int toupper (int c) { return islower (c) ? c - 'a' + 'A' : c; }$/;"	f
transform_string	device/ata.c	/^transform_string (char *buf, int len) $/;"	f	file:
true	include/stdbool.h	5;"	d
true	include/type.h	19;"	d
type	include/device/ata.h	/^  uint8_t type;$/;"	m	struct:ata_device
type	include/device/block.h	/^    blk_dev_t type;$/;"	m	struct:blk_dev
type	proc/proc.c	/^	unsigned char type;	\/\/0 : 직접실행, 1 : fork 함수실행$/;"	m	struct:__anon1	file:
type	stdio.c	/^    type;$/;"	m	struct:printf_conversion	typeref:enum:printf_conversion::__anon3	file:
uint16_t	include/stdint.h	/^typedef unsigned short int uint16_t;$/;"	t
uint16_t	include/type.h	/^typedef unsigned short int uint16_t;$/;"	t
uint32_t	include/stdint.h	/^typedef unsigned int uint32_t;$/;"	t
uint32_t	include/type.h	/^typedef unsigned int uint32_t;$/;"	t
uint64_t	include/stdint.h	/^typedef unsigned long long int uint64_t;$/;"	t
uint64_t	include/type.h	/^typedef unsigned long long int uint64_t;$/;"	t
uint8_t	include/stdint.h	/^typedef unsigned char uint8_t;$/;"	t
uint8_t	include/type.h	/^typedef unsigned char uint8_t;$/;"	t
uintmax_t	include/stdint.h	/^typedef unsigned long long int uintmax_t;$/;"	t
uintmax_t	include/type.h	/^typedef unsigned long long int uintmax_t;$/;"	t
uintptr_t	include/stdint.h	/^typedef uint32_t uintptr_t;$/;"	t
uintptr_t	include/type.h	/^typedef uint32_t uintptr_t;$/;"	t
uname_proc	proc/proc.c	/^void uname_proc(void* aux)$/;"	f
unused	include/filesys/file.h	/^	uint8_t unused;$/;"	m	struct:ssufile
used_map	mem/palloc.c	/^	struct bitmap *used_map;            \/* Bitmap of free pages. *\/$/;"	m	struct:pool	typeref:struct:pool::bitmap	file:
va_arg	include/stdarg.h	10;"	d
va_end	include/stdarg.h	11;"	d
va_list	include/stdarg.h	/^typedef char			*va_list;$/;"	t
va_start	include/stdarg.h	9;"	d
value	include/synch.h	/^      unsigned value;             \/* Current value. *\/$/;"	m	struct:semaphore
vec_no	include/interrupt.h	/^	uint32_t vec_no;            \/* Interrupt vector number. *\/$/;"	m	struct:intr_frame
view_bitmap	filesys/fs.c	/^void view_bitmap(struct bitmap *b)$/;"	f
vsnprintf	stdio.c	/^vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) $/;"	f
vsnprintf_aux	stdio.c	/^struct vsnprintf_aux $/;"	s	file:
vsnprintf_helper	stdio.c	/^vsnprintf_helper (char ch, void *aux_)$/;"	f	file:
vsprintf	include/stdio.h	38;"	d
vsprintk	vsprintk.c	/^int vsprintk(char *buf, const char *fmt, va_list args)$/;"	f
vtop	include/vaddr.h	/^vtop (const void *vaddr)$/;"	f
wait	arch/syscall.c	/^pid_t wait(int *status)$/;"	f
waiters	include/synch.h	/^      struct list waiters;        \/* List of waiting threads. *\/$/;"	m	struct:condition	typeref:struct:condition::list
waiters	include/synch.h	/^      struct list waiters;        \/* List of waiting threads. *\/$/;"	m	struct:semaphore	typeref:struct:semaphore::list
width	stdio.c	/^    int width;$/;"	m	struct:printf_conversion	file:
write	arch/syscall.c	/^int write(int fd, const char *buf, size_t len)$/;"	f
write	include/device/block.h	/^  void (*write) (void *blk_dev, blk_sec_t, const void *buf);$/;"	m	struct:blk_dev_ops
write_cr0	arch/i386/crset.asm	/^write_cr0:$/;"	l
write_cr3	arch/i386/crset.asm	/^write_cr3:$/;"	l
write_proc	proc/proc.c	/^void write_proc(void *aux)$/;"	f
x	stdio.c	/^    int x;                      \/* `x' character to use, for base 16 only. *\/$/;"	m	struct:integer_base	file:
zero	arch/i386/intr-stubs.S	/^#define zero                                \\$/;"	d
